[{"path":"/articles/introduction.html","id":"a-motivating-example","dir":"Articles","previous_headings":"","what":"A motivating example","title":"Introduction to `simmer.bricks`","text":"simmer package provides rich flexible API build discrete-event simulations. However, certain recurring patterns typed . common example probably spend time holding resource. Let us consider basic example Introduction simmer: seize > timeout > release blocks can substituted visit verb, included simmer.bricks: Internally, simmer.bricks just uses simmer verbs, trajectories equivalent: means must mind want use rollback() loop part trajectory. summary, simmer.bricks package repository simmer activity patterns like one. See help(package=\"simmer.bricks\") comprehensive list.","code":"library(simmer)  patient.1 <- trajectory(\"patients' path\") %>%   ## add an intake activity    seize(\"nurse\", 1) %>%   timeout(function() rnorm(1, 15)) %>%   release(\"nurse\", 1) %>%   ## add a consultation activity   seize(\"doctor\", 1) %>%   timeout(function() rnorm(1, 20)) %>%   release(\"doctor\", 1) %>%   ## add a planning activity   seize(\"administration\", 1) %>%   timeout(function() rnorm(1, 5)) %>%   release(\"administration\", 1) library(simmer.bricks)  patient.2 <- trajectory(\"patients' path\") %>%   ## add an intake activity    visit(\"nurse\", function() rnorm(1, 15)) %>%   ## add a consultation activity   visit(\"doctor\", function() rnorm(1, 20)) %>%   ## add a planning activity   visit(\"administration\", function() rnorm(1, 5)) patient.1 #> trajectory: patients' path, 9 activities #> { Activity: Seize        | resource: nurse, amount: 1 } #> { Activity: Timeout      | delay: function() } #> { Activity: Release      | resource: nurse, amount: 1 } #> { Activity: Seize        | resource: doctor, amount: 1 } #> { Activity: Timeout      | delay: function() } #> { Activity: Release      | resource: doctor, amount: 1 } #> { Activity: Seize        | resource: administration, amount: 1 } #> { Activity: Timeout      | delay: function() } #> { Activity: Release      | resource: administration, amount: 1 } patient.2 #> trajectory: patients' path, 9 activities #> { Activity: Seize        | resource: nurse, amount: 1 } #> { Activity: Timeout      | delay: function() } #> { Activity: Release      | resource: nurse, amount: 1 } #> { Activity: Seize        | resource: doctor, amount: 1 } #> { Activity: Timeout      | delay: function() } #> { Activity: Release      | resource: doctor, amount: 1 } #> { Activity: Seize        | resource: administration, amount: 1 } #> { Activity: Timeout      | delay: function() } #> { Activity: Release      | resource: administration, amount: 1 }"},{"path":[]},{"path":"/articles/introduction.html","id":"delayed-release","dir":"Articles","previous_headings":"More compelling examples","what":"Delayed release","title":"Introduction to `simmer.bricks`","text":"simulations require resource become inoperative time release. possible simulate simmer using technique call delayed release. Basically, arrival releases resource continues trajectory, clone latter keeps resource busy time required; finally, clone removed. main problem keeping resource busy must implemented different ways depending resource type, .e., whether preemptive . package encapsulates logic easy--use brick called delayed_release(): curious, can print trajectory see happens behind scenes.","code":"env <- simmer() %>%   add_resource(\"res1\") %>%   add_resource(\"res2\", preemptive=TRUE)  t <- trajectory() %>%   seize(\"res1\") %>%   log_(\"res1 seized\") %>%   seize(\"res2\") %>%   log_(\"res2 seized\") %>%   # inoperative for 2 units of time   delayed_release(\"res1\", 2) %>%    log_(\"res1 released\") %>%   # inoperative for 5 units of time   delayed_release(\"res2\", 5, preemptive=TRUE) %>%   log_(\"res2 released\")  env %>%   add_generator(\"dummy\", t, at(0, 1)) %>%   run() %>% invisible #> 0: dummy0: res1 seized #> 0: dummy0: res2 seized #> 0: dummy0: res1 released #> 0: dummy0: res2 released #> 2: dummy1: res1 seized #> 5: dummy1: res2 seized #> 5: dummy1: res1 released #> 5: dummy1: res2 released"},{"path":"/articles/introduction.html","id":"parallel-tasks","dir":"Articles","previous_headings":"More compelling examples","what":"Parallel tasks","title":"Introduction to `simmer.bricks`","text":"Another common pattern set number parallel tasks clone(). challenging original arrival resources seized. Let us consider following case, doctor nurse visiting patients hospital room: simulation fails. original arrival, seized room follows first path (doctor), finishes duty first place. Given wait = TRUE synchronize() activity, means last clone arrive (nurse case) continues, others removed. Solving requires ensuring original arrival reaches synchronize() activity last place (first place wait = FALSE), can tricky, asynchronous programming must used. However, simmer.bricks provides do_parallel() brick: everything just works.","code":"t <- trajectory() %>%   seize(\"room\") %>%   clone(     n = 2,     trajectory(\"doctor\") %>%       timeout(1),     trajectory(\"nurse\") %>%       timeout(2)) %>%   synchronize(wait = TRUE) %>%   timeout(0.5) %>%   release(\"room\",1)  simmer() %>%   add_resource(\"room\") %>%   add_generator(\"visit\", t, at(0)) %>%   run() #> Error: 'visit0' at 2.50 in [Timeout]->Release->[]: #>  'room' not previously seized env <- simmer()  t <- trajectory() %>%   seize(\"room\") %>%   log_(\"room seized\") %>%   do_parallel(     trajectory(\"doctor\") %>%       timeout(1) %>%       log_(\"doctor path done\"),     trajectory(\"nurse\") %>%       timeout(2) %>%       log_(\"nurse path done\"),     .env = env   ) %>%   timeout(0.5) %>%   release(\"room\",1) %>%   log_(\"room released\")  env %>%   add_resource(\"room\") %>%   add_generator(\"visit\", t, at(0)) %>%   run() %>% invisible #> 0: visit0: room seized #> 1: visit0: doctor path done #> 2: visit0: nurse path done #> 2.5: visit0: room released"},{"path":"/articles/introduction.html","id":"interleaved-resources","dir":"Articles","previous_headings":"More compelling examples","what":"Interleaved resources","title":"Introduction to `simmer.bricks`","text":"Assembly lines chains limited resources current resource released next one available. class problems can solved pattern called interleaved resources. pattern uses auxiliary resources guard access second subsequent resources chain, serving token guarded resource. consequence, resource blocked reason, tokens exhaust eventually, thus blockage propagate backwards. Let us consider chain two machines, B, whose service times 1 2 respectively. , chain resources can set follows: can seen, interleave brick uses auxiliary resource called \"B_token\" must defined . machine B capacity=1 queue_size=1, \"B_token\" must capacity=2 (B’s capacity + queue size) queue_size=Inf, avoid dropping arrivals. simuation , three arrivals processed machine 1 unit time. first two successfully seize token B, last arrival wait one leave B releasing .","code":"t <- trajectory() %>%   interleave(c(\"A\", \"B\"), c(1, 2))  t #> trajectory: anonymous, 8 activities #> { Activity: Seize        | resource: A, amount: 1 } #> { Activity: Timeout      | delay: 1 } #> { Activity: Seize        | resource: B_token, amount: 1 } #> { Activity: Release      | resource: A, amount: 1 } #> { Activity: Seize        | resource: B, amount: 1 } #> { Activity: Timeout      | delay: 2 } #> { Activity: Release      | resource: B, amount: 1 } #> { Activity: Release      | resource: B_token, amount: 1 } simmer() %>%   add_resource(\"A\", 3, 1) %>%   add_resource(\"B_token\", 2, Inf) %>%   add_resource(\"B\", 1, 1) %>%   add_generator(\"dummy\", t, at(rep(0, 3))) %>%   run(4) %>%   get_mon_arrivals(per_resource = TRUE) #>     name start_time end_time activity_time resource replication #> 1 dummy0          0        1             1        A           1 #> 2 dummy1          0        1             1        A           1 #> 3 dummy0          1        3             2        B           1 #> 4 dummy0          1        3             2  B_token           1 #> 5 dummy2          0        3             1        A           1"},{"path":"/articles/introduction.html","id":"contributing","dir":"Articles","previous_headings":"","what":"Contributing","title":"Introduction to `simmer.bricks`","text":"know patterns like see included simmer.bricks, please, open issue pull request GitHub.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Iñaki Ucar. Author, copyright holder, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ucar (2022). simmer.bricks: Helper Methods 'simmer' Trajectories. http://r-simmer.org, https://github.com/r-simmer/simmer.bricks.","code":"@Manual{,   title = {simmer.bricks: Helper Methods for 'simmer' Trajectories},   author = {Iñaki Ucar},   year = {2022},   note = {http://r-simmer.org, https://github.com/r-simmer/simmer.bricks}, }"},{"path":"/index.html","id":"bricks","dir":"","previous_headings":"","what":"Helper Methods for simmer Trajectories","title":"Helper Methods for simmer Trajectories","text":"simmer.bricks provides helper methods simmer, Discrete-Event Simulation (DES) package R. simmer brick wraps common activity pattern can used build trajectories conveniently.","code":""},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Helper Methods for simmer Trajectories","text":"Documentation available r-simmer.org/extensions/bricks/reference. get started, please explore vignettes online, R:","code":"vignette(package = \"simmer.bricks\")"},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Helper Methods for simmer Trajectories","text":"Install release version CRAN: installation GitHub requires remotes package.","code":"install.packages(\"simmer.bricks\") # install.packages(\"remotes\") remotes::install_github(\"r-simmer/simmer.bricks\")"},{"path":"/reference/delayed_release.html","id":null,"dir":"Reference","previous_headings":"","what":"Delayed Release of a Resource — delayed_release","title":"Delayed Release of a Resource — delayed_release","text":"brick encapsulates delayed release: arrival releases resource continues way immediately, resource busy additional period time.","code":""},{"path":"/reference/delayed_release.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delayed Release of a Resource — delayed_release","text":"","code":"delayed_release(   .trj,   resource,   task,   amount = 1,   preemptive = FALSE,   mon_all = FALSE )  delayed_release_selected(   .trj,   task,   amount = 1,   preemptive = FALSE,   mon_all = FALSE )"},{"path":"/reference/delayed_release.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delayed Release of a Resource — delayed_release","text":".trj trajectory object. resource name resource. task timeout duration supplied either passing numeric callable object (function) must return numeric (negative values automatically coerced positive). amount amount seize/release, accepts either numeric callable object (function) must return numeric. preemptive whether arrivals server can preempted based seize priorities. mon_all TRUE, get_mon_arrivals show one line per clone.","code":""},{"path":"/reference/delayed_release.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delayed Release of a Resource — delayed_release","text":"Returns following chain activities: clone > synchronize (see examples ).","code":""},{"path":"/reference/delayed_release.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delayed Release of a Resource — delayed_release","text":"","code":"## These are equivalent for a non-preemptive resource: trajectory() %>%   delayed_release(\"res1\", 5, 1) #> trajectory: anonymous, 6 activities #> { Activity: Clone        | n: 2 } #>   Fork 1, continue,  trajectory: anonymous, 2 activities #>   { Activity: SetCapacity  | resource: res1, value: -1, mod: + } #>   { Activity: Release      | resource: res1, amount: 1 } #>   Fork 2, continue,  trajectory: anonymous, 2 activities #>   { Activity: Timeout      | delay: 5 } #>   { Activity: SetCapacity  | resource: res1, value: 1, mod: + } #> { Activity: Synchronize  | wait: 0 }  trajectory() %>%   clone(     2,     trajectory() %>%       set_capacity(\"res1\", -1, mod=\"+\") %>%       release(\"res1\", 1),     trajectory() %>%       timeout(5) %>%       set_capacity(\"res1\", 1, mod=\"+\")   ) %>%   synchronize(wait=FALSE) #> trajectory: anonymous, 6 activities #> { Activity: Clone        | n: 2 } #>   Fork 1, continue,  trajectory: anonymous, 2 activities #>   { Activity: SetCapacity  | resource: res1, value: -1, mod: + } #>   { Activity: Release      | resource: res1, amount: 1 } #>   Fork 2, continue,  trajectory: anonymous, 2 activities #>   { Activity: Timeout      | delay: 5 } #>   { Activity: SetCapacity  | resource: res1, value: 1, mod: + } #> { Activity: Synchronize  | wait: 0 }  ## These are equivalent for a preemptive resource: trajectory() %>%   delayed_release(\"res2\", 5, 1, preemptive=TRUE) #> trajectory: anonymous, 7 activities #> { Activity: Clone        | n: 2 } #>   Fork 1, continue,  trajectory: anonymous, 1 activities #>   { Activity: Release      | resource: res2, amount: 1 } #>   Fork 2, continue,  trajectory: anonymous, 4 activities #>   { Activity: SetPrior     | values: [2147483647, 2147483647, 0], mod: N } #>   { Activity: Seize        | resource: res2, amount: 1 } #>   { Activity: Timeout      | delay: 5 } #>   { Activity: Release      | resource: res2, amount: 1 } #> { Activity: Synchronize  | wait: 0 }  trajectory() %>%   clone(     2,     trajectory() %>%       release(\"res2\", 1),     trajectory() %>%       set_prioritization(c(rep(.Machine$integer.max, 2), 0)) %>%       seize(\"res2\", 1) %>%       timeout(5) %>%       release(\"res2\", 1)   ) %>%   synchronize(wait=FALSE) #> trajectory: anonymous, 7 activities #> { Activity: Clone        | n: 2 } #>   Fork 1, continue,  trajectory: anonymous, 1 activities #>   { Activity: Release      | resource: res2, amount: 1 } #>   Fork 2, continue,  trajectory: anonymous, 4 activities #>   { Activity: SetPrior     | values: [2147483647, 2147483647, 0], mod: N } #>   { Activity: Seize        | resource: res2, amount: 1 } #>   { Activity: Timeout      | delay: 5 } #>   { Activity: Release      | resource: res2, amount: 1 } #> { Activity: Synchronize  | wait: 0 }"},{"path":"/reference/do_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Parallel Tasks — do_parallel","title":"Perform Parallel Tasks — do_parallel","text":"brick encapsulates activity n workers running parallel sub-trajectories.","code":""},{"path":"/reference/do_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Parallel Tasks — do_parallel","text":"","code":"do_parallel(.trj, ..., .env, wait = TRUE, mon_all = FALSE)"},{"path":"/reference/do_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Parallel Tasks — do_parallel","text":".trj trajectory object. ... sub-trajectories list sub-trajectories parallelise. .env simulation environment. wait TRUE, arrival waits parallel sub-trajectories finished; FALSE, arrival continues soon first parallel task ends. mon_all TRUE, get_mon_arrivals show one line per clone.","code":""},{"path":"/reference/do_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Parallel Tasks — do_parallel","text":"Returns following chain activities: clone > synchronize (> wait > untrap wait=FALSE) (see examples ).","code":""},{"path":"/reference/do_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Parallel Tasks — do_parallel","text":"","code":"env <- simmer() signal <- function() get_name(env)  task.1 <- trajectory(\"task 1\") %>%   timeout(function() rexp(1)) task.2 <- trajectory(\"task 2\") %>%   timeout(function() rexp(1))  ## These are equivalent: trajectory() %>%   do_parallel(     task.1,     task.2,     .env = env, wait = TRUE   ) #> trajectory: anonymous, 10 activities #> { Activity: Clone        | n: 3 } #>   Fork 1, continue,  trajectory: original, 4 activities #>   { Activity: Trap         | signals: function() } #>   { Activity: Wait         |  } #>   { Activity: Wait         |  } #>   { Activity: UnTrap       | signals: function() } #>   Fork 2, continue,  trajectory: task 1, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #>   Fork 3, continue,  trajectory: task 2, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #> { Activity: Synchronize  | wait: 1 }  trajectory() %>%   clone(     n = 3,     trajectory(\"original\") %>%       trap(signal) %>%       wait() %>%       wait() %>%       untrap(signal),     task.1[] %>%       send(signal),     task.2[] %>%       send(signal)) %>%   synchronize(wait = TRUE) #> trajectory: anonymous, 10 activities #> { Activity: Clone        | n: 3 } #>   Fork 1, continue,  trajectory: original, 4 activities #>   { Activity: Trap         | signals: function() } #>   { Activity: Wait         |  } #>   { Activity: Wait         |  } #>   { Activity: UnTrap       | signals: function() } #>   Fork 2, continue,  trajectory: task 1, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #>   Fork 3, continue,  trajectory: task 2, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #> { Activity: Synchronize  | wait: 1 }  ## These are equivalent: trajectory() %>%   do_parallel(     task.1,     task.2,     .env = env, wait = FALSE   ) #> trajectory: anonymous, 9 activities #> { Activity: Clone        | n: 3 } #>   Fork 1, continue,  trajectory: original, 1 activities #>   { Activity: Trap         | signals: function() } #>   Fork 2, continue,  trajectory: task 1, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #>   Fork 3, continue,  trajectory: task 2, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #> { Activity: Synchronize  | wait: 0 } #> { Activity: Wait         |  } #> { Activity: UnTrap       | signals: function() }  trajectory() %>%   clone(     n = 3,     trajectory(\"original\") %>%       trap(signal),     task.1[] %>%       send(signal),     task.2[] %>%       send(signal)) %>%   synchronize(wait = FALSE) %>%   wait() %>%   untrap(signal) #> trajectory: anonymous, 9 activities #> { Activity: Clone        | n: 3 } #>   Fork 1, continue,  trajectory: original, 1 activities #>   { Activity: Trap         | signals: function() } #>   Fork 2, continue,  trajectory: task 1, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #>   Fork 3, continue,  trajectory: task 2, 2 activities #>   { Activity: Timeout      | delay: function() } #>   { Activity: Send         | signals: function(), delay: 0 } #> { Activity: Synchronize  | wait: 0 } #> { Activity: Wait         |  } #> { Activity: UnTrap       | signals: function() }"},{"path":"/reference/interleave.html","id":null,"dir":"Reference","previous_headings":"","what":"Interleaved Resources — interleave","title":"Interleaved Resources — interleave","text":"brick encapsulates chain interleaved resources, .e., current resource released next one chain available. interesting property pattern , one resource blocked reason, whole chain stops.","code":""},{"path":"/reference/interleave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interleaved Resources — interleave","text":"","code":"interleave(.trj, resources, task, amount = 1)"},{"path":"/reference/interleave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interleaved Resources — interleave","text":".trj trajectory object. resources character vector resource names. task timeout duration supplied either passing numeric callable object (function) must return numeric (negative values automatically coerced positive). amount amount seize/release, accepts either numeric callable object (function) must return numeric.","code":""},{"path":"/reference/interleave.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interleaved Resources — interleave","text":"Returns following chain activities: seize (1) > timeout > [seize (token 2) > release (1) > seize (2) > timeout > release (2) > release (token 2) > ... (repeat) ] (see examples ). Thus, total number activities appended length(resources) * 3 + (length(resources)-1) * 2.","code":""},{"path":"/reference/interleave.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interleaved Resources — interleave","text":"task amount accept list values/functions, instead single one, length resources, value/function applied resource index. transition second subsequent resources guarded token, auxiliary resource whose capacity must equal capacity + queue size guarded resource, queue size must infinite. example, two resources provided, c(\"\", \"B\"), auxiliary resource named \"B_token\". capacity=2 queue_size=1 B, capacity=3 queue_size=Inf must values B_token. note user responsible adding auxiliary resource simulation environment appropriate parameters.","code":""},{"path":"/reference/interleave.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interleaved Resources — interleave","text":"","code":"## These are equivalent: trajectory() %>%   interleave(c(\"A\", \"B\"), c(2, 10), 1) #> trajectory: anonymous, 8 activities #> { Activity: Seize        | resource: A, amount: 1 } #> { Activity: Timeout      | delay: 2 } #> { Activity: Seize        | resource: B_token, amount: 1 } #> { Activity: Release      | resource: A, amount: 1 } #> { Activity: Seize        | resource: B, amount: 1 } #> { Activity: Timeout      | delay: 10 } #> { Activity: Release      | resource: B, amount: 1 } #> { Activity: Release      | resource: B_token, amount: 1 }  trajectory() %>%   seize(\"A\", 1) %>%   timeout(2) %>%   seize(\"B_token\", 1) %>%   release(\"A\", 1) %>%   seize(\"B\", 1) %>%   timeout(10) %>%   release(\"B\", 1) %>%   release(\"B_token\", 1) #> trajectory: anonymous, 8 activities #> { Activity: Seize        | resource: A, amount: 1 } #> { Activity: Timeout      | delay: 2 } #> { Activity: Seize        | resource: B_token, amount: 1 } #> { Activity: Release      | resource: A, amount: 1 } #> { Activity: Seize        | resource: B, amount: 1 } #> { Activity: Timeout      | delay: 10 } #> { Activity: Release      | resource: B, amount: 1 } #> { Activity: Release      | resource: B_token, amount: 1 }"},{"path":"/reference/simmer.bricks-package.html","id":null,"dir":"Reference","previous_headings":"","what":"simmer.bricks: Helper Methods for simmer Trajectories — simmer.bricks-package","title":"simmer.bricks: Helper Methods for simmer Trajectories — simmer.bricks-package","text":"Provides wrappers common activity patterns simmer trajectories.","code":""},{"path":[]},{"path":"/reference/simmer.bricks-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"simmer.bricks: Helper Methods for simmer Trajectories — simmer.bricks-package","text":"Iñaki Ucar","code":""},{"path":"/reference/visit.html","id":null,"dir":"Reference","previous_headings":"","what":"Visit a Resource — visit","title":"Visit a Resource — visit","text":"bricks encapsulate resource visit: seize, spend time release.","code":""},{"path":"/reference/visit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visit a Resource — visit","text":"","code":"visit(.trj, resource, task, amount = 1)  visit_selected(.trj, task, amount = 1, id = 0)"},{"path":"/reference/visit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visit a Resource — visit","text":".trj trajectory object. resource name resource. task timeout duration supplied either passing numeric callable object (function) must return numeric (negative values automatically coerced positive). amount amount seize/release, accepts either numeric callable object (function) must return numeric. id selection identifier nested usage.","code":""},{"path":"/reference/visit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visit a Resource — visit","text":"Returns following chain activities: seize > timeout > release (see examples ).","code":""},{"path":"/reference/visit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visit a Resource — visit","text":"","code":"## These are equivalent: trajectory() %>%   visit(\"res\", 5, 1) #> trajectory: anonymous, 3 activities #> { Activity: Seize        | resource: res, amount: 1 } #> { Activity: Timeout      | delay: 5 } #> { Activity: Release      | resource: res, amount: 1 }  trajectory() %>%   seize(\"res\", 1) %>%   timeout(5) %>%   release(\"res\", 1) #> trajectory: anonymous, 3 activities #> { Activity: Seize        | resource: res, amount: 1 } #> { Activity: Timeout      | delay: 5 } #> { Activity: Release      | resource: res, amount: 1 }  ## These are equivalent: trajectory() %>%   visit_selected(5, 1) #> trajectory: anonymous, 3 activities #> { Activity: Seize        | resource: [0], amount: 1 } #> { Activity: Timeout      | delay: 5 } #> { Activity: Release      | resource: [0], amount: 1 }  trajectory() %>%   seize_selected(1) %>%   timeout(5) %>%   release_selected(1) #> trajectory: anonymous, 3 activities #> { Activity: Seize        | resource: [0], amount: 1 } #> { Activity: Timeout      | delay: 5 } #> { Activity: Release      | resource: [0], amount: 1 }"},{"path":"/reference/wait_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Wait a Number of Signals — wait_n","title":"Wait a Number of Signals — wait_n","text":"bricks encapsulate n stops: wait sequence n signals. wait_until also traps untraps required signals.","code":""},{"path":"/reference/wait_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wait a Number of Signals — wait_n","text":"","code":"wait_n(.trj, n = 1)  wait_until(.trj, signals, n = 1)"},{"path":"/reference/wait_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wait a Number of Signals — wait_n","text":".trj trajectory object. n number wait activities chain. signals signal list signals, accepts either string, list strings callable object (function) must return string list strings.","code":""},{"path":"/reference/wait_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wait a Number of Signals — wait_n","text":"wait_n returns n times wait. wait_until also adds trap untrap beginning end, respectively, chain waits (see examples ).","code":""},{"path":"/reference/wait_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wait a Number of Signals — wait_n","text":"","code":"## These are equivalent: trajectory() %>%   wait_n(3) #> trajectory: anonymous, 3 activities #> { Activity: Wait         |  } #> { Activity: Wait         |  } #> { Activity: Wait         |  }  trajectory() %>%   wait() %>%   wait() %>%   wait() #> trajectory: anonymous, 3 activities #> { Activity: Wait         |  } #> { Activity: Wait         |  } #> { Activity: Wait         |  }  ## These are equivalent: trajectory() %>%   wait_until(\"green\") #> trajectory: anonymous, 3 activities #> { Activity: Trap         | signals: [green] } #> { Activity: Wait         |  } #> { Activity: UnTrap       | signals: [green] }  trajectory() %>%   trap(\"green\") %>%   wait() %>%   untrap(\"green\") #> trajectory: anonymous, 3 activities #> { Activity: Trap         | signals: [green] } #> { Activity: Wait         |  } #> { Activity: UnTrap       | signals: [green] }  ## These are equivalent: trajectory() %>%   wait_until(c(\"one\", \"another\"), 2) #> trajectory: anonymous, 4 activities #> { Activity: Trap         | signals: [one, another] } #> { Activity: Wait         |  } #> { Activity: Wait         |  } #> { Activity: UnTrap       | signals: [one, another] }  trajectory() %>%   trap(c(\"one\", \"another\")) %>%   wait() %>%   wait() %>%   untrap(c(\"one\", \"another\")) #> trajectory: anonymous, 4 activities #> { Activity: Trap         | signals: [one, another] } #> { Activity: Wait         |  } #> { Activity: Wait         |  } #> { Activity: UnTrap       | signals: [one, another] }"},{"path":"/news/index.html","id":"simmerbricks-0219000","dir":"Changelog","previous_headings":"","what":"simmer.bricks 0.2.1.9000","title":"simmer.bricks 0.2.1.9000","text":"Fix amount argument delayed_release() support functions (#16).","code":""},{"path":"/news/index.html","id":"simmerbricks-021","dir":"Changelog","previous_headings":"","what":"simmer.bricks 0.2.1","title":"simmer.bricks 0.2.1","text":"CRAN release: 2019-01-09 Fix tests simmer 4.2.0.","code":""},{"path":"/news/index.html","id":"simmerbricks-020","dir":"Changelog","previous_headings":"","what":"simmer.bricks 0.2.0","title":"simmer.bricks 0.2.0","text":"CRAN release: 2018-08-05","code":""},{"path":"/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"simmer.bricks 0.2.0","text":"Implement delayed_release_selected() (#9 addressing #4). New interleave() brick set interleaved resources (#11 addressing #7).","code":""},{"path":"/news/index.html","id":"minor-changes-and-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Minor changes and fixes","title":"simmer.bricks 0.2.0","text":"Fix do_parallel() also accept lists trajectories input (#6). Simplify delayed_release() interface (part #9). Change do_parallel() interface: move environment dots force user name (#10).","code":""}]
